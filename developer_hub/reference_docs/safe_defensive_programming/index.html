<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Learn about how to write safe and defensive code in your FRAME runtime. As our runtime should never panic; this includes carefully handling `Result`/`Option` types, eliminating the possibility of integer overflows, converting between number types, or even handling floating point usage with fixed point arithmetic to mitigate issues that come with floating point calculations."><title>developer_hub::reference_docs::safe_defensive_programming - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-fa3bb1812debf86c.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="developer_hub" data-themes="" data-resource-suffix="" data-rustdoc-version="1.74.0 (79e9716c9 2023-11-13)" data-channel="1.74.0" data-search-js="search-8be46b629f5f14a8.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../../../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="../../../static.files/main-c5bd66d33317d69f.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../developer_hub/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a></nav><nav class="sidebar"><a class="logo-container" href="../../../developer_hub/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module safe_defensive_programming</a></h2><div class="sidebar-elems"></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">developer_hub</a>::<wbr><a href="../index.html">reference_docs</a>::<wbr><a class="mod" href="#">safe_defensive_programming</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../src/developer_hub/reference_docs/safe_defensive_programming.rs.html#1-615">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Learn about how to write safe and defensive code in your FRAME runtime.
As our runtime should <em>never</em> panic; this includes carefully handling <a href="https://doc.rust-lang.org/1.74.0/core/result/enum.Result.html" title="enum core::result::Result"><code>Result</code></a>/<a href="https://doc.rust-lang.org/1.74.0/core/option/enum.Option.html" title="enum core::option::Option"><code>Option</code></a>
types, eliminating the possibility of integer overflows, converting between number types, or
even handling floating point usage with fixed point arithmetic to mitigate issues that come with
floating point calculations.</p>
<h3 id="defensive-programming"><a href="#defensive-programming">Defensive Programming</a></h3>
<p>Defensive programming is a design paradigm that enables a particular program to continue
running despite unexpected behavior. These unforseen circumstances may
cause the program to stop, (or in the Rust context, <code>panic!</code>) defensive practices allow for
these circumstances to be accounted for ahead of time, and for them to be handled in a more
graceful manner.</p>
<p>The Polkadot SDK is both built to reflect these principles, and to be used accordingly.</p>
<h3 id="general-practices"><a href="#general-practices">General Practices</a></h3>
<p>When developing within the context of the a runtime, there is one golden rule:</p>
<p><em><strong>DO NOT PANIC!</strong></em></p>
<p>Most of the time, unless you wish for your node to be intentionally brought down - panicking is
something that your runtime should feverishly protect against. This includes the following
considerations:</p>
<ul>
<li>Directly using <code>unwrap()</code> for a <a href="https://doc.rust-lang.org/1.74.0/core/result/enum.Result.html" title="enum core::result::Result"><code>Result</code></a> shouldn’t be used.</li>
<li>This includes accessing indices of some collection type, which may implicitly <code>panic!</code></li>
<li>It may be acceptable to use <code>except()</code>, but only if one is completely certain (and has
performed a check beforehand) that a value won’t panic upon unwrapping.</li>
<li>If you are writing a function that could panic, <a href="https://doc.rust-lang.org/rustdoc/how-to-write-documentation.html#documenting-components">be sure to document it!</a></li>
<li>Many seemingly, simplistic operations, such as <strong>arithmetic</strong> in the runtime, could present a
number of issues <a href="#integer-overflow">(see more later in this document)</a>.</li>
</ul>
<h4 id="general-practices---examples"><a href="#general-practices---examples">General Practices - Examples</a></h4>
<p>Below are examples of the above concepts in action - it will show what <em>problematic</em> code looks
like, versus proper form.</p>
<p>The following presents a rather obvious issue - one should always use the default of the type,
or handle the error accordingly:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>bad_unwrap() {
	<span class="kw">let </span>some_result: <span class="prelude-ty">Result</span>&lt;u32, <span class="kw-2">&amp;</span>str&gt; = <span class="prelude-val">Ok</span>(<span class="number">10</span>);
	<span class="macro">assert_eq!</span>(some_result.unwrap(), <span class="number">10</span>);
}</code></pre></div>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>good_unwrap() {
	<span class="kw">let </span>some_result: <span class="prelude-ty">Result</span>&lt;u32, <span class="kw-2">&amp;</span>str&gt; = <span class="prelude-val">Err</span>(<span class="string">&quot;Error&quot;</span>);
	<span class="macro">assert_eq!</span>(some_result.unwrap_or_default(), <span class="number">0</span>);
	<span class="macro">assert_eq!</span>(some_result.unwrap_or(<span class="number">10</span>), <span class="number">10</span>);
}</code></pre></div>
<p>Other operations, such as indexing a vector (or a similar scenario like looping and accessing it
in a similar fashion) must also be tread with caution:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>bad_collection_retrieval() {
	<span class="kw">let </span>my_list = <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
	<span class="comment">// THIS PANICS!
	// Indexing on heap allocated values, i.e., vec, can be unsafe!
	</span><span class="macro">assert_eq!</span>(my_list[<span class="number">5</span>], <span class="number">6</span>)
}</code></pre></div>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>good_collection_retrieval() {
	<span class="kw">let </span>my_list = <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
	<span class="comment">// Rust includes `.get`, returning Option&lt;T&gt; - so lets use that:
	</span><span class="macro">assert_eq!</span>(my_list.get(<span class="number">5</span>), <span class="prelude-val">None</span>)
}</code></pre></div>
<h4 id="defensive-traits"><a href="#defensive-traits">Defensive Traits</a></h4>
<p>To also aid in debugging and mitigating the above issues, there is a
<a href="../../../frame_support/traits/misc/trait.Defensive.html" title="trait frame_support::traits::misc::Defensive"><code>Defensive</code></a> trait (and its companions,
<a href="../../../frame_support/traits/misc/trait.DefensiveOption.html" title="trait frame_support::traits::misc::DefensiveOption"><code>DefensiveOption</code></a>,
<a href="../../../frame_support/traits/misc/trait.DefensiveResult.html" title="trait frame_support::traits::misc::DefensiveResult"><code>DefensiveResult</code></a>)that can be used to defensively unwrap
values.  This can be used in place of
an <code>expect</code>, and again, only if the developer is sure about the unwrap in the first place.</p>
<p>The <a href="../../../frame_support/traits/misc/trait.Defensive.html" title="trait frame_support::traits::misc::Defensive"><code>Defensive</code></a> trait provides a number of functions, all of which
provide an alternative to ‘vanilla’ Rust functions:</p>
<ul>
<li><a href="../../../frame_support/traits/misc/trait.Defensive.html#tymethod.defensive_unwrap_or" title="method frame_support::traits::misc::Defensive::defensive_unwrap_or"><code>defensive_unwrap_or()</code></a></li>
<li><a href="../../../frame_support/traits/misc/trait.DefensiveOption.html#tymethod.defensive_ok_or" title="method frame_support::traits::misc::DefensiveOption::defensive_ok_or"><code>defensive_ok_or()</code></a></li>
</ul>
<p>The primary difference here is when <code>debug_assertions</code> are enabled, that they panic, but in
production/release, they will merely log an error via the logging instance the runtime is using
(i.e., <code>log::error</code>).</p>
<p>This is useful for catching issues in the development environment, without risking panicing in production.</p>
<h3 id="integer-overflow"><a href="#integer-overflow">Integer Overflow</a></h3>
<p>The Rust compiler prevents any sort of static overflow from happening at compile time, for
example:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>overflow = u8::MAX + <span class="number">10</span>;</code></pre></div>
<p>Would yield the following error:</p>
<div class="example-wrap"><pre class="language-text"><code>error: this arithmetic operation will overflow
   --&gt; src/main.rs:121:24
    |
121 |         let overflow = u8::MAX + 10;
    |                        ^^^^^^^^^^^^ attempt to compute `u8::MAX + 10_u8`, which would overflow
    |
</code></pre></div>
<p>However in the runtime context, we don’t always have control over what is being supplied as a
parameter. For example, even this simple adding function could present one of two outcomes
depending on whether it is in <strong>release</strong> or <strong>debug</strong> mode:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>naive_add(x: u8, y: u8) -&gt; u8 {
	x + y
}</code></pre></div>
<p>If we passed in overflow-able values at runtime, this could actually panic (or wrap, if in
release).</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code>naive_add(<span class="number">250u8</span>, <span class="number">10u8</span>); <span class="comment">// In debug mode, this would panic. In release, this would return 4.</span></code></pre></div>
<p>The Rust compiler would panic in <strong>debug</strong> mode in the event of an integer overflow. In
<strong>release</strong> mode, it resorts to silently <em>wrapping</em> the overflowed amount in a modular fashion,
(hence returning <code>4</code>).</p>
<p>It is actually the <em>silent</em> portion of this behavior that presents a real issue - as it may be
an unintended, but also a very <em>silent killer</em> in terms of producing bugs. In fact, it would
have been better for this type of behavior to produce some sort of error, or even <code>panic!</code>, as
in that scenario, at least such behavior could become obvious. Especially in the context of
blockchain development, where unsafe arithmetic could produce unexpected consequences.</p>
<p>A quick example is a user’s balance overflowing: the default behavior of wrapping could result
in the user’s balance starting from zero, or vice versa, of a <code>0</code> balance turning into the <code>MAX</code>
of some type. Naturally, this could lead to various exploits and issues down the road, which if
failing silently, would be difficult to trace and rectify.</p>
<p>Luckily, there are ways to both represent and handle these scenarios depending on our specific
use case natively built into Rust, as well as libraries like [<code>sp_arithmetic</code>].</p>
<h3 id="infallible-arithmetic"><a href="#infallible-arithmetic">Infallible Arithmetic</a></h3>
<p>Our main objective in runtime development is to reduce the likelihood of any <em>unintended</em> or
<em>undefined</em> behavior. Intentional and predictable design should be our first and foremost
property for ensuring a well running, safely designed system. Both Rust and Substrate both
provide safe ways to deal with numbers and alternatives to floating point arithmetic.</p>
<p>Rather they (should) use fixed-point arithmetic to mitigate the potential for inaccuracy,
rounding errors, or other unexpected behavior. For more on the specifics of the peculiarities of floating point calculations, <a href="https://www.youtube.com/watch?v=PZRI1IfStY0">watch this video by the Computerphile</a>.</p>
<p>Using <strong>primitive</strong> floating point number types in a blockchain context should also be avoided,
as a single nondeterministic result could cause chaos for consensus along with the
aforementioned issues.</p>
<p>The following methods represent different ways one can handle numbers safely natively in Rust,
without fear of panic or unexpected behavior from wrapping.</p>
<h4 id="checked-operations"><a href="#checked-operations">Checked Operations</a></h4>
<p><strong>Checked operations</strong> utilize a <code>Option&lt;T&gt;</code> as a return type. This allows for simple pattern
matching to catch any unexpected behavior in the event of an overflow.</p>
<p>This is an example of a valid operation:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>checked_add_example() {
	<span class="comment">// This is valid, as 20 is perfectly within the bounds of u32.
	</span><span class="kw">let </span>add = (<span class="number">10u32</span>).checked_add(<span class="number">10</span>);
	<span class="macro">assert_eq!</span>(add, <span class="prelude-val">Some</span>(<span class="number">20</span>))
}</code></pre></div>
<p>This is an example of an invalid operation, in this case, a simulated integer overflow, which
would simply result in <code>None</code>:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>checked_add_handle_error_example() {
	<span class="comment">// This is invalid - we are adding something to the max of u32::MAX, which would overflow.
	// Luckily, checked_add just marks this as None!
	</span><span class="kw">let </span>add = u32::MAX.checked_add(<span class="number">10</span>);
	<span class="macro">assert_eq!</span>(add, <span class="prelude-val">None</span>)
}</code></pre></div>
<p>Typically, if you aren’t sure about which operation to use for runtime math, <strong>checked</strong>
operations are a safe bet, as it presents two, predictable (and <em>erroring</em>) outcomes that can be
handled accordingly (<code>Some</code> and <code>None</code>).</p>
<p>In a practical context, the resulting <a href="https://doc.rust-lang.org/1.74.0/core/option/enum.Option.html" title="enum core::option::Option"><code>Option</code></a> should be handled accordingly. The following
conventions can be seen from the within the Polkadot SDK, where it can be handled in one of
two ways:</p>
<ul>
<li>As an <a href="https://doc.rust-lang.org/1.74.0/core/option/enum.Option.html" title="enum core::option::Option"><code>Option</code></a>, using the <code>if let</code> / <code>if</code> or <code>match</code></li>
<li>As a <a href="https://doc.rust-lang.org/1.74.0/core/result/enum.Result.html" title="enum core::result::Result"><code>Result</code></a>, via <code>ok_or</code> (or similar conversion to <a href="https://doc.rust-lang.org/1.74.0/core/result/enum.Result.html" title="enum core::result::Result"><code>Result</code></a> from <a href="https://doc.rust-lang.org/1.74.0/core/option/enum.Option.html" title="enum core::option::Option"><code>Option</code></a>)</li>
</ul>
<h5 id="handling-via-option---more-verbose"><a href="#handling-via-option---more-verbose">Handling via Option - More Verbose</a></h5>
<p>Because wrapped operations return <code>Option&lt;T&gt;</code>, you can use a more verbose/explicit form of error
handling via <code>if</code> or <code>if let</code>:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>increase_balance(account: Address, amount: u64) -&gt; <span class="prelude-ty">Result</span>&lt;(), BlockchainError&gt; {
	<span class="comment">// Get a user&#39;s current balance
	</span><span class="kw">let </span>balance = Runtime::get_balance(account)<span class="question-mark">?</span>;
	<span class="comment">// SAFELY increase the balance by some amount
	</span><span class="kw">if let </span><span class="prelude-val">Some</span>(new_balance) = balance.checked_add(amount) {
		Runtime::set_balance(account, new_balance);
		<span class="kw">return </span><span class="prelude-val">Ok</span>(());
	} <span class="kw">else </span>{
		<span class="kw">return </span><span class="prelude-val">Err</span>(BlockchainError::Overflow);
	}
}</code></pre></div>
<p>Optionally, <code>match</code> may also be directly used in a more concise manner:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>increase_balance_match(account: Address, amount: u64) -&gt; <span class="prelude-ty">Result</span>&lt;(), BlockchainError&gt; {
	<span class="comment">// Get a user&#39;s current balance
	</span><span class="kw">let </span>balance = Runtime::get_balance(account)<span class="question-mark">?</span>;
	<span class="comment">// SAFELY increase the balance by some amount
	</span><span class="kw">let </span>new_balance = <span class="kw">match </span>balance.checked_add(amount) {
		<span class="prelude-val">Some</span>(balance) =&gt; balance,
		<span class="prelude-val">None </span>=&gt; {
			<span class="kw">return </span><span class="prelude-val">Err</span>(BlockchainError::Overflow);
		},
	};
	Runtime::set_balance(account, new_balance);
	<span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>This is generally a useful convention for handling not only checked types, but most types that
return <code>Option&lt;T&gt;</code>.</p>
<h5 id="handling-via-result---less-verbose"><a href="#handling-via-result---less-verbose">Handling via Result - Less Verbose</a></h5>
<p>In the Polkadot SDK codebase, you may see checked operations being handled as a <a href="https://doc.rust-lang.org/1.74.0/core/result/enum.Result.html" title="enum core::result::Result"><code>Result</code></a> via
<code>ok_or</code>. This is a less verbose way of expressing the above.  Which to use often boils down to
the developer’s preference:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>increase_balance_result(account: Address, amount: u64) -&gt; <span class="prelude-ty">Result</span>&lt;(), BlockchainError&gt; {
	<span class="comment">// Get a user&#39;s current balance
	</span><span class="kw">let </span>balance = Runtime::get_balance(account)<span class="question-mark">?</span>;
	<span class="comment">// SAFELY increase the balance by some amount - this time, by using `ok_or`
	</span><span class="kw">let </span>new_balance = balance.checked_add(amount).ok_or_else(|| BlockchainError::Overflow)<span class="question-mark">?</span>;
	Runtime::set_balance(account, new_balance);
	<span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h4 id="saturated-operations"><a href="#saturated-operations">Saturated Operations</a></h4>
<p>Saturating a number limits it to the type’s upper or lower bound, no matter the integer would
overflow in runtime. For example, adding to <code>u32::MAX</code> would simply limit itself to <code>u32::MAX</code>:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>saturated_add_example() {
	<span class="comment">// Saturating add simply saturates
	// to the numeric bound of that type if it overflows.
	</span><span class="kw">let </span>add = u32::MAX.saturating_add(<span class="number">10</span>);
	<span class="macro">assert_eq!</span>(add, u32::MAX)
}</code></pre></div>
<p>Saturating calculations can be used if one is very sure that something won’t overflow, but wants
to avoid introducing the notion of any potential-panic or wrapping behavior.</p>
<p>There is also a series of defensive alternatives via
<a href="../../../frame_support/traits/misc/trait.DefensiveSaturating.html" title="trait frame_support::traits::misc::DefensiveSaturating"><code>DefensiveSaturating</code></a>, which introduces the same behavior
of the <a href="../../../frame_support/traits/misc/trait.Defensive.html" title="trait frame_support::traits::misc::Defensive"><code>Defensive</code></a> trait, only with saturating, mathematical
operations:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
#[should_panic(expected = <span class="string">&quot;Defensive failure has been triggered!&quot;</span>)]
</span><span class="kw">fn </span>saturated_defensive_example() {
	<span class="kw">let </span>saturated_defensive = u32::MAX.defensive_saturating_add(<span class="number">10</span>);
	<span class="macro">assert_eq!</span>(saturated_defensive, u32::MAX);
}</code></pre></div>
<h4 id="mathematical-operations-in-substrate-development---further-context"><a href="#mathematical-operations-in-substrate-development---further-context">Mathematical Operations in Substrate Development - Further Context</a></h4>
<p>As a recap, we covered the following concepts:</p>
<ol>
<li><strong>Checked</strong> operations - using <a href="https://doc.rust-lang.org/1.74.0/core/option/enum.Option.html" title="enum core::option::Option"><code>Option</code></a> or <a href="https://doc.rust-lang.org/1.74.0/core/result/enum.Result.html" title="enum core::result::Result"><code>Result</code></a>,</li>
<li><strong>Saturated</strong> operations - limited to the lower and upper bounds of a number type,</li>
<li><strong>Wrapped</strong> operations (the default) - wrap around to above or below the bounds of a type,</li>
</ol>
<p>Known scenarios that could be fallible should be avoided: i.e., avoiding the possibility of
dividing/modulo by zero at any point should be mitigated.  One should be, instead, opting for a
<code>checked_</code> method in order to introduce safe arithmetic in their code.</p>
<h5 id="the-problem-with-default-wrapped-operations"><a href="#the-problem-with-default-wrapped-operations">The problem with ‘default’ wrapped operations</a></h5>
<p><strong>Wrapped operations</strong> cause the overflow to wrap around to either the maximum or minimum of
that type. Imagine this in the context of a blockchain, where there are balances, voting
counters, nonces for transactions, and other aspects of a blockchain.</p>
<p>Some of these mechanisms can be more critical than others. It’s for this reason that we may
consider some other ways of dealing with runtime arithmetic, such as saturated or checked
operations, that won’t carry these potential consequences.</p>
<p>While it may seem trivial, choosing how to handle numbers is quite important. As a thought
exercise, here are some scenarios of which will shed more light on when to use which.</p>
<h5 id="bobs-overflowed-balance"><a href="#bobs-overflowed-balance">Bob’s Overflowed Balance</a></h5>
<p><strong>Bob’s</strong> balance exceeds the <code>Balance</code> type on the <code>EduChain</code>. Because the pallet developer did
not handle the calculation to add to Bob’s balance with any regard to this overflow, <strong>Bob’s</strong>
balance is now essentially <code>0</code>, the operation <strong>wrapped</strong>.</p>
<details>
  <summary><b>Solution: Saturating or Checked</b></summary>
    For Bob's balance problems, using a `saturated_add` or `checked_add` could've mitigated this
issue.  They simply would've reached the upper, or lower bounds, of the particular type for an
on-chain balance.  In other words: Bob's balance would've stayed at the maximum of the Balance
type. </details>
<h5 id="alices-underflowed-balance"><a href="#alices-underflowed-balance">Alice’s ‘Underflowed’ Balance</a></h5>
<p>Alice’s balance has reached <code>0</code> after a transfer to Bob. Suddenly, she has been slashed on
<code>EduChain</code>, causing her balance to reach near the limit of <code>u32::MAX</code> - a very large amount - as
<em>wrapped operations</em> can go both ways. Alice can now successfully vote using her new,
overpowered token balance, destroying the integrity of the chain.</p>
<details>
  <summary><b>Solution: Saturating</b></summary>
  For Alice's balance problem, using `saturated_sub` could've mitigated this issue.  As debt or
  having a negative balance is not a concept within blockchains, a saturating calculation
would've   simply limited her balance to the lower bound of u32.
<p>In other words: Alice’s balance would’ve stayed at “0”, even after being slashed.</p>
<p>This is also an example that while one system may work in isolation, shared interfaces, such
as the notion of balances, are often shared across multiple pallets - meaning these small
changes can make a big difference in outcome. </details></p>
<h5 id="proposals-id-overwrite"><a href="#proposals-id-overwrite">Proposals’ ID Overwrite</a></h5>
<p>The type for counting the number of proposals on-chain is represented by a <code>u8</code> number, called
<code>proposals_count</code>. Every time a new proposal is added to the system, this number increases. With
the proposal pallet being high in usage, it has reached <code>u8::MAX</code>’s limit of <code>255</code>, causing
<code>proposals_count</code> to go to <code>0</code>. Unfortunately, this resulted in new proposals overwriting old
ones, effectively erasing any notion of past proposals!</p>
<details>
 <summary><b>Solution: Checked</b></summary>
For the proposal IDs, proper handling via `checked` math would've been much more suitable,
Saturating could've been used - but it also would've 'failed' silently.  Using `checked_add` to
ensure that the next proposal ID would've been valid would've been a viable way to let the user
know the state of their proposal:

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>next_proposal_id = current_count.checked_add(<span class="number">1</span>).ok_or_else(|| Error::TooManyProposals)<span class="question-mark">?</span>;</code></pre></div>
</details>
<p>From the above, we can clearly see the problematic nature of seemingly simple operations in
runtime. Of course, it may be that using checked math is perfectly fine under some scenarios -
such as certain balance being never realistically attainable, or a number type being so large
that it could never realistically overflow unless one sent thousands of transactions to the
network.</p>
<h4 id="decision-chart-when-to-use-which"><a href="#decision-chart-when-to-use-which">Decision Chart: When to use which?</a></h4><pre class="mermaid" style="text-align:center;background: transparent;">
flowchart LR
    CH["Checked"]
    ST["Saturated"]
    CH-->NEED["The user needs to know that the operation failed - and why"]
    CH-->DOUBT["Unsure whether this operation could fail/overflow"]
    ST-->SILENT["Silently reaching upper/lower bound will not result in any damage"]
    ST-->REASON["In all reasonable circumstances, the number will not overflow, but safety is still desired"]

</pre><script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";var doc_theme = localStorage.getItem("rustdoc-theme");if (doc_theme === "dark" || doc_theme === "ayu") mermaid.initialize({theme: "dark"});</script>
<h3 id="fixed-point-arithmetic"><a href="#fixed-point-arithmetic">Fixed Point Arithmetic</a></h3>
<p>The following code uses types from [<code>sp_arithmetic</code>].</p>
<p>Fixed point arithmetic solves the aforementioned problems of dealing with the uncertain
nature of floating point numbers. Rather than use a radix point (<code>0.80</code>), a type which
<em>represents</em> a floating point number in base 10, i.e., a <strong>fixed point number</strong>, can be used
instead.</p>
<p>For use cases which operate within the range of <code>[0, 1]</code> types which implement
<a href="sp_arithmetic::PerThing"><code>PerThing</code></a> are used:</p>
<ul>
<li><strong><a href="sp_arithmetic::Perbill"><code>Perbill</code></a>, parts of a billion</strong></li>
</ul>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>perbill_example() {
	<span class="kw">let </span>p = Perbill::from_percent(<span class="number">80</span>);
	<span class="comment">// 800000000 bil, or a representative of 0.800000000.
	// Precision is in the billions place.
	</span><span class="macro">assert_eq!</span>(p.deconstruct(), <span class="number">800000000</span>);
}</code></pre></div>
<ul>
<li><strong><a href="sp_arithmetic::Percent"><code>Percent</code></a>, parts of a hundred</strong></li>
</ul>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>percent_example() {
	<span class="kw">let </span>percent = Percent::from_rational(<span class="number">190u32</span>, <span class="number">400u32</span>);
	<span class="macro">assert_eq!</span>(percent.deconstruct(), <span class="number">47</span>);
}</code></pre></div>
<p>Note that <code>190 / 400 = 0.475</code>, and that <code>Percent</code> represents it as a <em>rounded down</em>, fixed point
number (<code>47</code>). Unlike primitive types, types that implement
<a href="sp_arithmetic::PerThing"><code>PerThing</code></a> will also not overflow, and are therefore safe to use.
They adopt the same behavior that a saturated calculation would provide, meaning that if one is
to go over “100%”, it wouldn’t overflow, but simply stop at the upper or lower bound.</p>
<p>For use cases which require precision beyond the range of <code>[0, 1]</code>, there are a number of other
fixed-point types to use:</p>
<ul>
<li><a href="sp_arithmetic::FixedU64"><code>FixedU64</code></a> and <a href="sp_arithmetic::FixedI64"><code>FixedI64</code></a></li>
<li><a href="sp_arithmetic::FixedU128"><code>FixedI128</code></a> and <a href="sp_arithmetic::FixedI128"><code>FixedU128</code></a></li>
</ul>
<p>Similar to types that implement <a href="sp_arithmetic::PerThing"><code>PerThing</code></a>, these are also
fixed-point types, however, they are able to represent larger numbers:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>fixed_u64() {
	<span class="comment">// The difference between this and perthings is perthings operates within the relam of [0,
	// 1] In cases where we need &gt; 1, we can used fixed types such as FixedU64

	</span><span class="kw">let </span>rational_1 = FixedU64::from_rational(<span class="number">10</span>, <span class="number">5</span>); <span class="comment">//&quot; 200%&quot; aka 2.
	</span><span class="kw">let </span>rational_2 =
		FixedU64::from_rational_with_rounding(<span class="number">5</span>, <span class="number">10</span>, sp_arithmetic::Rounding::Down); <span class="comment">// &quot;50%&quot; aka 0.50...

	</span><span class="macro">assert_eq!</span>(rational_1, (<span class="number">2u64</span>).into());
	<span class="macro">assert_eq!</span>(rational_2.into_perbill(), Perbill::from_float(<span class="number">0.5</span>));
}</code></pre></div>
<p>Let’s now explore these types in practice, and how they may be used with pallets to perform
safer calculations in the runtime.</p>
<h4 id="perthing-in-practice"><a href="#perthing-in-practice">‘PerThing’ In Practice</a></h4>
<p>[<code>sp_arithmetic</code>] contains a trait called <a href="sp_arithmetic::PerThing"><code>PerThing</code></a>, allowing a
custom type to be implemented specifically for fixed point arithmetic. While a number of
fixed-point types are introduced, let’s focus on a few specific examples that implement
<a href="sp_arithmetic::PerThing"><code>PerThing</code></a>:</p>
<ul>
<li><a href="sp_arithmetic::Percent"><code>Percent</code></a> - parts of one hundred.</li>
<li><a href="sp_arithmetic::Permill"><code>Permill</code></a> - parts of a million.</li>
<li><a href="sp_arithmetic::Perbill"><code>Perbill</code></a> - parts of a billion.</li>
</ul>
<p>Each of these can be used to construct and represent ratios within our runtime.
You will find types like <a href="sp_arithmetic::Perbill"><code>Perbill</code></a> being used often in pallet
development.  [<code>pallet_referenda</code>] is a good example of a pallet which makes good use of fixed
point arithmetic to calculate</p>
<p>Let’s examine the usage of <code>Perbill</code> and how exactly we can use it as an alternative to floating
point numbers in Substrate development. For this scenario, let’s say we are demonstrating a
<em>voting</em> system which depends on reaching a certain threshold, or percentage, before it can be
deemed valid.</p>
<p>For most cases, <code>Perbill</code> gives us a reasonable amount of precision for most applications, which
is why we’re using it here.</p>
<h5 id="fixed-point-arithmetic-with-perthing"><a href="#fixed-point-arithmetic-with-perthing">Fixed Point Arithmetic with <code>PerThing</code></a></h5>
<p>As stated, one can also perform mathematics using these types directly. For example, finding the
percentage of a particular item:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>percent_mult() {
	<span class="kw">let </span>percent = Percent::from_rational(<span class="number">5u32</span>, <span class="number">100u32</span>); <span class="comment">// aka, 5%
	</span><span class="kw">let </span>five_percent_of_100 = percent * <span class="number">100u32</span>; <span class="comment">// 5% of 100 is 5.
	</span><span class="macro">assert_eq!</span>(five_percent_of_100, <span class="number">5</span>)
}</code></pre></div>
<h4 id="fixed-point-types-in-practice"><a href="#fixed-point-types-in-practice">Fixed Point Types in Practice</a></h4>
<p>As said earlier, if one needs to exceed the value of one, then
<a href="sp_arithmetic::FixedU64"><code>FixedU64</code></a> (and its signed and <code>u128</code> counterparts) can be utilized.
Take for example this very rudimentary pricing mechanism, where we wish to calculate the demand
/ supply to get a price for some on-chain compute:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>fixed_u64_block_computation_example() {
	<span class="comment">// Cores available per block
	</span><span class="kw">let </span>supply = <span class="number">10u128</span>;
	<span class="comment">// Cores being ordered per block
	</span><span class="kw">let </span>demand = <span class="number">5u128</span>;
	<span class="comment">// Calculate a very rudimentry on-chain price from supply / demand
	</span><span class="kw">let </span>price = FixedU64::from_rational(demand, supply);

	<span class="comment">// 0.5 DOT per core
	</span><span class="macro">assert_eq!</span>(price, FixedU64::from_float(<span class="number">0.5</span>));

	<span class="comment">// Now, the story has changed - lots of demand means we buy as many cores as there
	// available.  This also means that price goes up! For the sake of simplicity, we don&#39;t care
	// about who gets a core - just about our very simple price model

	// Cores available per block
	</span><span class="kw">let </span>supply = <span class="number">10u128</span>;
	<span class="comment">// Cores being ordered per block
	</span><span class="kw">let </span>demand = <span class="number">19u128</span>;
	<span class="comment">// Calculate a very rudimentary on-chain price from supply / demand
	</span><span class="kw">let </span>price = FixedU64::from_rational(demand, supply);

	<span class="comment">// 1.9 DOT per core
	</span><span class="macro">assert_eq!</span>(price, FixedU64::from_float(<span class="number">1.9</span>));
}</code></pre></div>
<p>For a much more comprehensive example, be sure to look at the source for [<code>pallet_broker</code>]</p>
<h5 id="fixed-point-types-in-practice-1"><a href="#fixed-point-types-in-practice-1">Fixed Point Types in Practice</a></h5>
<p>Just as with <a href="sp_arithmetic::PerThing"><code>PerThing</code></a>, you can also perform regular mathematical
expressions:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>fixed_u64_operation_example() {
	<span class="kw">let </span>rational_1 = FixedU64::from_rational(<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// &quot;200%&quot; aka 2.
	</span><span class="kw">let </span>rational_2 = FixedU64::from_rational(<span class="number">8</span>, <span class="number">5</span>); <span class="comment">// &quot;160%&quot; aka 1.6.

	</span><span class="kw">let </span>addition = rational_1 + rational_2;
	<span class="kw">let </span>multiplication = rational_1 * rational_2;
	<span class="kw">let </span>division = rational_1 / rational_2;
	<span class="kw">let </span>subtraction = rational_1 - rational_2;

	<span class="macro">assert_eq!</span>(addition, FixedU64::from_float(<span class="number">3.6</span>));
	<span class="macro">assert_eq!</span>(multiplication, FixedU64::from_float(<span class="number">3.2</span>));
	<span class="macro">assert_eq!</span>(division, FixedU64::from_float(<span class="number">1.25</span>));
	<span class="macro">assert_eq!</span>(subtraction, FixedU64::from_float(<span class="number">0.4</span>));
}</code></pre></div>
<h3 id="other-resources"><a href="#other-resources">Other Resources</a></h3>
<ul>
<li><a href="https://polkadot-blockchain-academy.github.io/pba-book/substrate/tips-tricks/page.html?highlight=perthing#substrate-and-frame-tips-and-tricks">PBA Book - FRAME Tips &amp; Tricks</a></li>
</ul>
</div></details></section></div></main></body></html>